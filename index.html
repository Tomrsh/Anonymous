<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LiteChat — UltraLite PWA</title>
<meta name="theme-color" content="#071023">
<style>
/* Ultra minimal CSS (kept tiny) */
:root{--bg:#071023;--fg:#e6eef6;--accent:#06b6d4;--muted:#8b99a8}
html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,\"Noto Sans\";}
.app{max-width:720px;margin:12px auto;padding:12px}
.top{display:flex;align-items:center}
.brand{font-weight:700;color:var(--accent)}
.status{margin-left:auto;font-size:13px;color:var(--muted)}
.card{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;margin-top:10px}
.chats{height:56vh;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:8px}
.msg{max-width:78%;padding:8px;border-radius:8px;font-size:14px}
.mine{align-self:flex-end;background:linear-gradient(180deg,#063b3f,#045c63)}
.other{align-self:flex-start;background:rgba(255,255,255,0.03)}
.meta{font-size:11px;color:var(--muted);margin-top:4px}
.inputbar{display:flex;gap:6px;margin-top:8px}
input,button{padding:10px;border-radius:8px;border:0;background:rgba(255,255,255,0.02);color:inherit}
input{flex:1}
.small{font-size:12px;color:var(--muted);margin-top:6px}
</style>
</head>
<body>
<div class="app">
  <div class="top"><div class="brand">⚡ LiteChat Ultra</div><div id="net" class="status">checking...</div></div>
  <div class="card">
    <div id="join" style="display:block">
      <input id="name" placeholder="Your name (max 16 chars)" />
      <button id="joinBtn">Join</button>
    </div>
    <div id="ui" style="display:none">
      <div class="chats" id="chats"></div>
      <div class="inputbar">
        <input id="msg" placeholder="Type (keep short)" />
        <button id="send">Send</button>
      </div>
      <div class="small">Optimized: tiny payloads, batching, compression, adaptive retry. Works over 1-2kb/s.</div>
    </div>
  </div>
</div><!-- Minimal external libs: Firebase compat + LZ-String for compression --><script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script><script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script><script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script><script>
/*
  LiteChat Ultra — single-file PWA-ready starter
  IMPORTANT: Replace firebaseConfig with your project's config.
  Steps:
   1) Replace firebaseConfig below.
   2) Enable Anonymous Auth in Firebase Console.
   3) Create Realtime Database and set rules (dev example at bottom).
   4) Host on HTTPS (Firebase Hosting / Netlify) for best results.
   5) Register service worker (see comment at bottom to create 'sw.js').

  Design highlights to work well at 1-2 kb/s:
   - Per-message compression with LZString (UTF-16 variant) -> small repetitive messages compress a lot.
   - Short keys and batched pushes: multiple msgs grouped under one push node to reduce overhead.
   - Adaptive batching window: increases when network is slow to group more messages and avoid many tiny pushes.
   - Backoff strategy for retries to avoid flooding.
   - Limit real-time subscription to last N units.
*/

const firebaseConfig = {
  apiKey: "AIzaSyA3yJFkZO0gu-oEto3z4ZeqwN-rHxVn9-4",
  authDomain: "user-s-login-6260a.firebaseapp.com",
  databaseURL: "https://user-s-login-6260a-default-rtdb.firebaseio.com",
  projectId: "user-s-login-6260a",
  storageBucket: "user-s-login-6260a.firebasestorage.app",
  messagingSenderId: "896227638466",
  appId: "1:896227638466:web:d5bbf34936682dd4a70f5b",
  measurementId: "G-0HERWKBQ5Y"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

// CONFIG small and tuned
const CHAT_NODE = 'lc/m'; // short path
const MAX_SUB = 30; // only last N nodes
const QUEUE_KEY = 'lc_q_v3';
let displayName = '';
let user = null;
let online = navigator.onLine;
const netEl = document.getElementById('net');
const joinEl = document.getElementById('join');
const uiEl = document.getElementById('ui');
const nameIn = document.getElementById('name');
const joinBtn = document.getElementById('joinBtn');
const chats = document.getElementById('chats');
const msgIn = document.getElementById('msg');
const sendBtn = document.getElementById('send');

function updateNet(){ online = navigator.onLine; netEl.textContent = online ? 'online' : 'offline'; }
window.addEventListener('online', ()=>{ updateNet(); flushQueue(); });
window.addEventListener('offline', updateNet);
updateNet();

// tiny local queue helpers
function qLoad(){ try { return JSON.parse(localStorage.getItem(QUEUE_KEY)||'[]'); } catch(e){ return []; } }
function qSave(q){ localStorage.setItem(QUEUE_KEY, JSON.stringify(q)); }
function qPush(item){ const q=qLoad(); q.push(item); qSave(q); }
function qShift(n){ const q=qLoad(); const out=q.splice(0,n); qSave(q); return out; }
function qLen(){ return qLoad().length; }

// Compression + tiny format
// Each message: {t:ts,u:u,m:compressedText}
function packMsg(u, text){
  // simple dictionary micro-optimization: common words -> tokens
  const dict = ['hi','ok','yes','no','thanks','pls','please','brb','on','off','msg'];
  let s = text.toLowerCase();
  for(let i=0;i<dict.length;i++) s = s.replace(new RegExp('\\b'+dict[i]+'\\b','g'), '\\x'+(i+1));
  const comp = LZString.compressToUTF16(s); // compress to small UTF16 string
  return {t: Date.now(), u: u.slice(0,12), m: comp};
}
function unpackMsg(o){
  try{
    let s = o.m ? LZString.decompressFromUTF16(o.m) : '';
    // restore tokens
    const dict = ['hi','ok','yes','no','thanks','pls','please','brb','on','off','msg'];
    for(let i=0;i<dict.length;i++) s = s.replace(new RegExp('\\x'+(i+1),'g'), dict[i]);
    return {t:o.t,u:o.u,m:s};
  }catch(e){return {t:o.t,u:o.u,m:''};}
}

// Render functions
function renderLocal(msg, opts={}){
  const d = unpackMsg(msg);
  const el = document.createElement('div'); el.className='msg '+(d.u===displayName? 'mine':'other');
  el.innerHTML = '<div>'+escapeHtml(d.m)+'</div><div class="meta">'+escapeHtml(d.u)+' • '+new Date(d.t).toLocaleTimeString()+'</div>';
  if(opts.pending) { const p=document.createElement('span'); p.className='meta'; p.textContent=' • pending'; el.appendChild(p); }
  chats.appendChild(el); chats.scrollTop = chats.scrollHeight;
}
function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c])); }

// Batching control (adaptive)
let flushTimer = null;
let adaptiveWindow = 1000; // starts 1s; increases under slow network
let backoff = 1000; // backoff when failure
let sending = false;
const MAX_BATCH = 8;

function scheduleFlush(){ if(flushTimer) return; flushTimer = setTimeout(()=>{ flushTimer=null; doFlush(); }, adaptiveWindow); }

async function doFlush(){
  if(sending) return; if(!online) return;
  const len = qLen(); if(len===0) return;
  const batchSize = Math.min(len, MAX_BATCH);
  const items = qShift(batchSize);
  // push as single node: {b:1,n:count,ts:now,msgs:[...]} to reduce per-push overhead
  const node = {b:1,n:items.length,ts:Date.now(),msgs:items};
  sending = true;
  try{
    const ref = db.ref(CHAT_NODE).push();
    await new Promise((res,rej)=>{ ref.set(node, (err)=> err?rej(err):res()); });
    // success -> shrink adaptiveWindow slightly to be more responsive
    adaptiveWindow = Math.max(500, Math.floor(adaptiveWindow*0.9));
    backoff = 1000;
  }catch(err){
    // failure: put items back at front (preserve order)
    const q=qLoad(); q.unshift(...items); qSave(q);
    // increase window + backoff
    adaptiveWindow = Math.min(15000, adaptiveWindow*1.5);
    backoff = Math.min(60000, backoff*1.8);
    setTimeout(()=>{ sending=false; scheduleFlush(); }, backoff);
    return;
  }
  sending = false;
  // after push, to avoid hammering, schedule another flush later
  setTimeout(()=>{ scheduleFlush(); }, 300);
}

// send API (enqueue)
function sendText(s){ const p = packMsg(displayName, s); qPush(p); renderLocal(p, {pending:true}); scheduleFlush(); }

// Queue flushing triggered when app comes online
function flushQueue(){ scheduleFlush(); }

// init listeners (reads batch nodes and single nodes)
function initListeners(){
  const ref = db.ref(CHAT_NODE).limitToLast(MAX_SUB);
  ref.off();
  ref.on('child_added', snap=>{
    const val = snap.val(); if(!val) return;
    if(val.b && Array.isArray(val.msgs)){
      val.msgs.forEach(m=>{ renderLocal(m, {delivered:true}); });
    } else if(val.m){ renderLocal(val, {delivered:true}); }
  });
  // replay any local queued messages as pending
  qLoad().forEach(x=> renderLocal(x, {pending:true}));
}

// UI wiring
joinBtn.onclick = async ()=>{
  const n = (nameIn.value||'').trim().slice(0,16); if(!n) return alert('enter name'); displayName = n;
  try{ const r = await auth.signInAnonymously(); user = r.user; joinEl.style.display='none'; uiEl.style.display='block'; initListeners(); flushQueue(); }
  catch(e){ alert('auth failed'); }
  localStorage.setItem('lc_name', displayName);
};
nameIn.value = localStorage.getItem('lc_name')||'';
sendBtn.onclick = ()=>{ const t = (msgIn.value||'').trim(); if(!t) return; msgIn.value=''; sendText(t); };
msgIn.addEventListener('keypress', e=>{ if(e.key==='Enter') sendBtn.click(); });

// small periodic presence ping (rate-limited)
setInterval(()=>{ if(!user) return; db.ref('lc/p/'+user.uid).set({n:displayName,t:Date.now()}).catch(()=>{}); },60000);

// simple trimming helper (best-effort client-side)
setInterval(()=>{ try{ const ref = db.ref(CHAT_NODE).limitToLast(MAX_SUB); ref.once('value', snap=>{ const keep=[]; snap.forEach(c=>keep.push(c.key)); db.ref(CHAT_NODE).once('value', all=>{ all.forEach(c=>{ if(!keep.includes(c.key)) db.ref(CHAT_NODE+'/'+c.key).remove().catch(()=>{}); }); }); }); }catch(e){} },60*60*1000);

// register a minimal service worker for PWA caching if available (create sw.js separately)
if('serviceWorker' in navigator){ navigator.serviceWorker.register('/sw.js').catch(()=>{}); }

// DEV: simple DB rules example (paste in Firebase console during testing):
/*
{
  "rules": {
    "lc": {
      "m": { 
        ".read": "auth != null",
        ".write": "auth != null",
        "$msg": {
          ".validate": "newData.hasChildren(['ts']) || newData.hasChildren(['t'])"
        }
      },
      "p": { ".read": true, ".write": "auth != null" }
    }
  }
}
*/

</script></body>
</html>
